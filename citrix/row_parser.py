from common.rss_base_row_parser import RSSBaseRowParser
from common.html_parser import HTMLParser
from datetime import datetime
from bs4 import BeautifulSoup


class RowParser(RSSBaseRowParser): 

    def __init__(self, from_date_string, to_date_string):
        super().__init__(from_date_string, to_date_string)
        self.cve_tag = "title"

    
    def get_cells(self,row):
        self.version_soup = self.build_version_soup(row.link.text)
        self.current_row = BeautifulSoup(row.description.text, 'html.parser') 
        return row
    
    def get_cve_id(self, row):
        heading = super().get_cve_id(row)
        if heading.startswith("CVE"):
            return heading.split()[0]
        # row.link.text.rsplit("/", 1)[1]
        return None 

    def get_product(self, row, vendor, product):
        return  row.find_all("category")

    def get_version_string(self, row):
        if self.version_soup is not None:
            version_string = ""
            for li in self.version_soup.find_all("li"):
                version = li.text.rsplit(" ",1)[1]
                if version[0].isdigit():
                    version_string += li.text.rsplit(" ",1)[1]+","
            return version_string.strip(",")
        return self.extract_version_from_description(row)
    
    def get_cpes(self, row, vendor, product):
        cpe23Uri_is_required = self.get_cve_id(row).startswith("CVE")
        return self.parse_cpes(self.get_version_string(row),
                                    vendor,
                                    self.get_product(row, vendor, product), cpe23Uri_is_required)
    
    def build_version_soup(self, url):
         parser = HTMLParser(url)
         desc = parser.get_tag_by_id("DescriptionofProblem")
         if desc is not None:
            uls = desc.parent.find_all("ul")
            for ul in uls:
                ul_heading = ul.previous_sibling.previous_sibling.text
                if self.is_affected_version_list(ul_heading):
                    return ul

    def is_affected_version_list(self, text):
        if text.find("affected") != -1:
            return True
        return False

    def extract_version_from_description(self, row):
        all_p = self.current_row.find_all("p")
        for p in all_p:
            if p.text.find("Applicable Products") != -1 :
                spans = p.find_all("span")
                spans = spans[1:]
                products = self.get_product(row, None, None)
                version_string = ""
                version_dict = dict()
                for product in products:
                    for span in spans:
                        versions = span.text.split(product.text)
                        if len(versions) == 2:
                            version_string += versions[1].strip("_").replace("_",".")+","
                    version_string = version_string.strip(",")
                    version_dict[product] = version_string
                    version_string = ""
                return version_dict






