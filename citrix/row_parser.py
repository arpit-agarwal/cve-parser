from common.rss_base_row_parser import RSSBaseRowParser
from common.html_parser import HTMLParser
from common.utils import find_any, safe_split
from datetime import datetime
from bs4 import BeautifulSoup
import re

class RowParser(RSSBaseRowParser): 

    def __init__(self, from_date_string, to_date_string):
        super().__init__(from_date_string, to_date_string)
        self.cve_tag = "title"

    
    def get_cells(self,row):
        self.link_parser = HTMLParser(row.link.text)
        self.product_list = self.build_product_list(self.link_parser)
        self.versions_list = self.build_version_list(self.link_parser)
        # print(self.versions_list)
        self.current_row = BeautifulSoup(row.description.text, 'html.parser') 
        return row
    
    def get_cve_id(self, row):
        heading = super().get_cve_id(row)
        if heading.startswith("CVE"):
            return heading.split()[0]
        # row.link.text.rsplit("/", 1)[1]
        return None 

    def get_product(self, row, vendor, product):
        return  self.product_list

    def get_product_version_pairs(self, row):
            version_string = ""
            product_versions_pair = {}
            if self.versions_list is not None:
                for item in self.versions_list:
                    # print(item)
                    if not isinstance(item, str):
                        item = item.text
                    dict_ = self.extract_version_from_li(item.strip("*").strip())
                    if dict_ is not None:
                        product_name = dict_.get("product_name")
                        product_name_2 = dict_.get("product_name_2")
                        start_version = dict_.get("start_version")
                        end_version = dict_.get("end_version")
                        exclude_end_version = dict_.get("exclude_end_version")
                        os = dict_.get("os")
                        # print(exclude_end_version)
                        version = None
                        if os is not None:
                            # print(os)
                            if os == "iPhone":
                                product_name = "Citrix Receiver for iPhone"
                            for product in self.product_list:
                                if product.find(os) != -1:
                                    # product_versions_pair[product] = "prior to {}".format(exclude_end_version)
                                    product_name = product
                                    splits = exclude_end_version.split("and")
                                    exclude_end_version = splits[0].strip()
                                    if len(splits) == 2:
                                        exclude_end_version_2 = splits[1].strip().rsplit(" ",1)[1]
                                        product_versions_pair[product_name] = ["prior to {}".format(exclude_end_version_2)]
                                if find_any(product, ["Java", "UNIX"]):
                                    product_versions_pair[product] = [None]
                            

                        if exclude_end_version is not None:
                            version = "prior to {}".format(exclude_end_version)
                        elif start_version is None and end_version is not None: 
                            version = "before {}".format(end_version)
                        elif end_version is None and start_version is not None:
                            version = "from {}".format(start_version)
                        elif start_version is not None and end_version is not None:
                            version = "from {} to {}".format(start_version, end_version)

                        product_name = product_name.strip("\u2022").strip()
                        versions_per_product = product_versions_pair.get(product_name)

                        if versions_per_product is None:
                            product_versions_pair[product_name] = [version]
                        else:
                            product_versions_pair[product_name].append(version)

                        if product_name_2 is not None:
                            product_name_2 = product_name_2.strip("\u2022").strip()
                            versions_per_product = product_versions_pair.get(product_name_2)

                            if versions_per_product is None:
                                product_versions_pair[product_name_2] = [version]
                            else:
                                product_versions_pair[product_name_2].append(version)

                # version = li.text.rsplit(" ",1)[1]
                # if version[0].isdigit():
                #     version_string += li.text.rsplit(" ",1)[1]+","
          
            return product_versions_pair
        # return self.extract_version_from_description(row)
    def extract_version_from_li(self, text):
        formats = [ 
                    "All versions of {product_name} {start_version}" ,
                    "All versions of {product_name} {end_version} and earlier" ,
                    "All versions of {product_name} {version} earlier than {exclude_end_version}",
                    "{product_name} and {product_name_2} version {version} all supported builds before {exclude_end_version}",
                    "{product_name} {garbage} all supported software release builds before {exclude_end_version}",
                    "{product_name} earlier than build {exclude_end_version}",
                    "{product_name} for Windows earlier than {exclude_end_version}",
                    "{product_name} all supported versions",
                    "{product_name} Update {end_version} and earlier",
                    "Citrix Online Plug-in for {os}: version {exclude_end_version} and later",
                    "Citrix Receiver for {os}: version {exclude_end_version} and later"
                    
        ]
        format_string = "{product_name}"
        earlier_than_index = text.find("earlier than")
        update_index = text.find("Update")
        for_windows_earlier_than_index = text.find("for Windows earlier than")
        earlier_than_build_index = text.find("earlier than build")
        all_supported_index = text.find("all supported versions")
        earlier_index = text.find("and earlier")
        all_supported_builds_before = text.find("all supported builds before")
        all_supported_sowftware_builds_before = text.find("all supported software release builds before")
        
        add_update_prefix = False
        if text.find("Citrix Receiver for") != -1:
            format_string = formats[10]
        elif text.find("Citrix Online Plug-in for") != -1:
            format_string = formats[9]
        elif update_index != -1:
            format_string = formats[8]
            add_update_prefix = True
        elif for_windows_earlier_than_index != -1:
            format_string = formats[6]
        elif all_supported_index != -1 :
            format_string = formats[7]
        elif earlier_than_build_index != -1:
            format_string = formats[5]
            text = self.product_list[0]+" "+text
        elif all_supported_sowftware_builds_before != -1:
            format_string = formats[4]
        elif all_supported_builds_before != -1:
            format_string = formats[3]
        elif earlier_than_index != -1:
            format_string = formats[2]
        elif earlier_index != -1:
            format_string = formats[1] 
        elif text.find("All versions of ") != -1:
            format_string = formats[0]
        # print("text: {}\n format:{}".format(text, format_string))
        dict_ = self.string_to_dict(text, format_string)
        if add_update_prefix:
            dict_["end_version"] = "Update "+dict_["end_version"]
            # print(dict_["end_version"])
        return dict_
  
    
    def string_to_dict(self, string, pattern):
        regex = re.sub(r'{(.+?)}', r'(?P<_\1>.+)', pattern)
        search_terms = re.search(regex, string)
        if search_terms is not None:
            values = list(search_terms.groups())
            keys = re.findall(r'{(.+?)}', pattern)
            _dict = dict(zip(keys, values))
            return _dict


    def get_cpes(self, row, vendor, product):
        cpe23Uri_is_required = self.get_cve_id(row).startswith("CVE")
        pairs = self.get_product_version_pairs(row)
        products = self.get_product(row,vendor, product)
        versions = [""]
        if pairs is not None and len(pairs) > 0:
            products = pairs.keys()
            versions = pairs
        # print(products)
        return self.parse_cpes(versions, vendor, products
                                        , cpe23Uri_is_required)
    
    def build_product_list(self, link_parser):
         products = link_parser.get_tag_by_class("citrixproductslist").find("ul").find_all("li")
         product_names = list()
         for product in products:
             product_names.append(product.text)
         return product_names

    def build_version_list(self, link_parser):
         desc = link_parser.get_tag_by_id("DescriptionofProblem")
         if desc is None:
             desc = link_parser.get_tag_by_class("parbase section text")
         if desc is not None:
            # print(desc)
            uls = desc.parent.find_all("ul")
            if len(uls) > 0 :
                for ul in uls:
                    # print(ul.prettify())
                    ul_heading = ul.previous_sibling.previous_sibling.text
                    # print(ul_heading)
                    if self.is_affected_version_list(ul_heading):
                        # print("in")
                        lis = ul.find_all("li")
                        if not lis:
                            lis = ul.find_all("p")
                        return lis
                    if self.is_resolved_version_list(ul_heading):
                        lis = ul.find_all("p")
                        return lis
            if len(uls) == 0:
                version_list = self.parse_versions_from_p_tag(link_parser)
                if len(version_list) > 0 :
                    return version_list
                


    def parse_versions_from_p_tag(self, link_parser):
        outer_div = link_parser.get_tag_by_class("parbase section text")
        # print(outer_div.prettify())
        versions_list = list()
        if outer_div is not None:
            all_p_tags = outer_div.find_all("p")
            if len(all_p_tags) > 1 :
                affected_version_p_tag = None
                for p_tag in all_p_tags:
                    if self.is_affected_version_list(p_tag.text):
                        # print(p_tag)
                        affected_version_p_tag = p_tag
                        continue
                    if affected_version_p_tag is not None:
                        # print(p_tag)
                        versions_list.append(p_tag)
            if len(all_p_tags) == 1:
                text = all_p_tags[0].text
                splits = safe_split(text, "This vulnerability affects the following product versions:")
                len_splits = len(splits)
                if splits is not None and len_splits > 1:
                    versions_string = splits[1].strip()
                    # print(versions_string)
                    product = self.product_list[0]
                    versions_list = versions_string.split(product)
                    versions_list = versions_list[1:]
        return versions_list
        
    def is_affected_version_list(self, text):
        return find_any(text.lower(), ["affected versions:", 
        "the vulnerability affects the following supported product versions", 
        "this vulnerability affects the following product versions",
        "this vulnerability affects the following citrix license server versions",
        ] )

    def is_resolved_version_list(self, text):
        return find_any(text.lower(), [
            "this issue has been resolved in the following"
        ] )


    def extract_version_from_description(self, row):
        all_p = self.current_row.find_all("p")
        for p in all_p:
            if p.text.find("Applicable Products") != -1 :
                spans = p.find_all("span")
                spans = spans[1:]
                products = self.get_product(row, None, None)
                version_string = ""
                version_dict = dict()
                for product in products:
                    for span in spans:
                        versions = span.text.split(product.text)
                        if len(versions) == 2:
                            version_string += versions[1].strip("_").replace("_",".")+","
                    version_string = version_string.strip(",")
                    version_dict[product] = version_string
                    version_string = ""
                return version_dict






