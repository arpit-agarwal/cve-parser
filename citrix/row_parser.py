from common.row_parser import BaseRowParser
from common.html_parser import HTMLParser
from datetime import datetime
from bs4 import BeautifulSoup


class RowParser(BaseRowParser): 
    
    def __init__(self):
        self.timestamp_format = '%Y-%m-%dT%H:%MZ'
        self.publishing__date_input_format = "%a, %d %b %Y %H:%M:%S %Z"

    def get_cells(self,row):
        self.version_soup = self.build_version_soup(row.link.text)
        self.current_row = BeautifulSoup(row.description.text, 'html.parser') 
        return row

    def build_version_soup(self, url):
         parser = HTMLParser(url)
         desc = parser.get_tag_by_id("DescriptionofProblem")
         if desc is not None:
            uls = desc.parent.find_all("ul")
            for ul in uls:
                ul_heading = ul.previous_sibling.previous_sibling.text
                if self.is_affected_version_list(ul_heading):
                    return ul

    def is_affected_version_list(self, text):
        if text.find("affected") != -1:
            return True
        return False

    def get_publish_date(self, row):
        return datetime.strptime(
                row.pubDate.text,
                self.publishing__date_input_format)

    def get_version_string(self, row):
        if self.version_soup is not None:
            version_string = ""
            for li in self.version_soup.find_all("li"):
                version = li.text.rsplit(" ",1)[1]
                if version[0].isdigit():
                    version_string += li.text.rsplit(" ",1)[1]+","
            return version_string.strip(",")
        return self.extract_version_from_description(row)

 
    def extract_version_from_description(self, row):
        all_p = self.current_row.find_all("p")
        for p in all_p:
            if p.text.find("Applicable Products") != -1 :
                spans = p.find_all("span")
                spans = spans[1:]
                products = self.get_product(row, None, None)
                version_string = ""
                version_dict = dict()
                for product in products:
                    for span in spans:
                        versions = span.text.split(product.text)
                        if len(versions) == 2:
                            version_string += versions[1].strip("_").replace("_",".")+","
                    version_string = version_string.strip(",")
                    version_dict[product] = version_string
                    version_string = ""
                return version_dict


    def get_product(self, row, vendor, product):
        return  row.find_all("category")

    def get_cve_id(self, row):
        heading = row.title.text
        if heading.startswith("CVE"):
            return heading.split()[0]
        return row.link.text.rsplit("/", 1)[1]

    def get_description(self, row):
        return row.title.text

    def get_product_name(self, current_product_node):
        return current_product_node.text

    def get_cpe_list(self, vendor, product, category, cpes):
        tuples = list()
        i=0
        for current_product in product:
            current_product_versions = cpes
            if type(cpes) is dict:
                current_product_versions = cpes[current_product]
            current_product_tuple = self.get_cpe_list_per_product(vendor, self.get_product_name(current_product), category, current_product_versions)
            tuples += current_product_tuple
            i =+ 1
        return tuples
    
    def get_cpe_list_per_product(self, vendor, product, category, cpes):
        if cpes is None:
            cpes_list = [cpes]
        else:
            cpes_list = cpes.split(",")
        return [(vendor, product, category, cpes_list)]

    def get_cpes(self, row, vendor, product):
        cpe23Uri_is_required = self.get_cve_id(row).startswith("CVE")
        return self.parse_cpes(self.get_version_string(row),
                                    vendor,
                                    self.get_product(row, vendor, product), cpe23Uri_is_required)







