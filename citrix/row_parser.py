from common.rss_base_row_parser import RSSBaseRowParser
from common.html_parser import HTMLParser
from common.utils import find_any, safe_split
from datetime import datetime
from bs4 import BeautifulSoup
import re

class RowParser(RSSBaseRowParser): 

    def __init__(self, from_date_string, to_date_string):
        super().__init__(from_date_string, to_date_string)
        self.cve_tag = "title"
        self.last_modified_date_tag = "pubDate"
        self.publishing_date_tag = None
        self.publishing__date_input_format="Created:Â %d %b %Y"

    
    def get_cells(self,row):
        self.link_parser = HTMLParser(row.link.text)
        self.product_list = self.build_product_list(self.link_parser)
        self.versions_list = self.build_version_list(self.link_parser)
        self.build_meta_info(self.link_parser)
        # print(self.versions_list)
        self.current_row = BeautifulSoup(row.description.text, 'html.parser') 
        return row
    
    def get_cve_id(self, row):
        heading = super().get_cve_id(row)
        if heading.startswith("CVE"):
            return heading.split()[0]
        # row.link.text.rsplit("/", 1)[1]
        return None 

    def get_product(self, row, vendor, product):
        return  self.product_list

    def get_publish_date(self, row, date=None):       
        return datetime.strptime(self.publishing_date_string,
                self.publishing__date_input_format)

    def get_cvsv3_severity(self,cells):
        return self.normalize_severity(self.severity)


    def get_product_version_pairs(self, row):
            version_string = ""
            product_versions_pair = {}
            if self.versions_list is not None:
                for item in self.versions_list:
                    # print(item)
                    if not isinstance(item, str):
                        item = item.text
                    dict_ = self.extract_version_from_li(item.strip("*").strip())
                    if dict_ is not None:
                        product_name = dict_.get("product_name")
                        # product_name_2 = dict_.get("product_name_2")
                        start_version = dict_.get("start_version")
                        end_version = dict_.get("end_version")
                        exclude_end_version = dict_.get("exclude_end_version")
                        os = dict_.get("os")
                        # print(exclude_end_version)
                        version = None
                        if os is not None:
                            # print(os)
                            if os == "iPhone":
                                product_name = "Citrix Receiver for iPhone"
                            for product in self.product_list:
                                if product.find(os) != -1:
                                    # product_versions_pair[product] = "prior to {}".format(exclude_end_version)
                                    product_name = product
                                    splits = exclude_end_version.split("and")
                                    exclude_end_version = splits[0].strip()
                                    if len(splits) == 2:
                                        exclude_end_version_2 = splits[1].strip().rsplit(" ",1)[1]
                                        product_versions_pair[product_name] = ["prior to {}".format(exclude_end_version_2)]
                                if find_any(product, ["Java", "UNIX"]):
                                    product_versions_pair[product] = [None]
                            
                        if product_name is None:
                            products = self.product_list
                        elif product_name[0].isdigit():
                            products = self.product_list
                        else:
                            products = safe_split(product_name, " and ")
                            if products is None:
                                product_name = product_name.strip("\u2022").strip()
                                products = [product_name]
                            elif len(products) > 1:
                                splited = safe_split(products[1], " version ")
                                if splited is not None and len(splited) == 2:
                                    exclude_end_version = "{} Build {}".format(splited[1], exclude_end_version)
                                    products[1] = splited[0].strip()
                        
                        if exclude_end_version is not None:
                            exclude_end_version = exclude_end_version.strip(".")
                            version = "prior to {}".format(exclude_end_version)
                        elif start_version is None and end_version is not None: 
                            version = "before {}".format(end_version)
                        elif end_version is None and start_version is not None:
                            version = "from {}".format(start_version)
                        elif start_version is not None and end_version is not None:
                            version = "from {} to {}".format(start_version, end_version)
                        
                        # if product_name_2 is not None:
                        #     product_name_2 = product_name_2.strip("\u2022").strip()
                        #     products.append(product_name_2)
                        
                        for product_name in products:
                            product_name = product_name.strip("\u2022").strip()
                            versions_per_product = product_versions_pair.get(product_name)

                            if versions_per_product is None:
                                product_versions_pair[product_name] = [version]
                            else:
                                product_versions_pair[product_name].append(version)

                # version = li.text.rsplit(" ",1)[1]
                # if version[0].isdigit():
                #     version_string += li.text.rsplit(" ",1)[1]+","
          
            return product_versions_pair
        # return self.extract_version_from_description(row)
    def extract_version_from_li(self, text):
        # print(text)
        formats = [ 
                    "All versions of {product_name} {start_version}" ,
                    "All versions of {product_name} {end_version} and earlier" ,
                    "All versions of {product_name} {version} earlier than {exclude_end_version}",
                    "{product_name} version {version} all supported builds before {exclude_end_version}",
                    "{product_name} {garbage} all supported software release builds before {exclude_end_version}",
                    "{product_name} earlier than build {exclude_end_version}",
                    "{product_name} for Windows earlier than {exclude_end_version}",
                    "{product_name} all supported versions",
                    "{product_name} Update {end_version} and earlier",
                    "Citrix Online Plug-in for {os}: version {exclude_end_version} and later",
                    "Citrix Receiver for {os}: version {exclude_end_version} and later",
                    "{product_name} earlier than version {exclude_end_version}",
                    "{product_name} before Rolling {exclude_end_version}"
                    
        ]
        format_string = "{product_name}"
        earlier_than_index = text.find("earlier than")
        update_index = text.find("Update")
        for_windows_earlier_than_index = text.find("for Windows earlier than")
        earlier_than_build_index = text.find("earlier than build")
        all_supported_index = text.find("all supported versions")
        earlier_index = text.find("and earlier")
        all_supported_builds_before = text.find("all supported builds before")
        all_supported_sowftware_builds_before = text.find("all supported software release builds before")
        
        add_update_prefix = False
        if text.find(" before Rolling ") != -1:
            format_string = formats[12]
        elif text.find("earlier than version ") != -1:
            format_string = formats[11]
        elif text.find("Citrix Receiver for") != -1:
            format_string = formats[10]
        elif text.find("Citrix Online Plug-in for") != -1:
            format_string = formats[9]
        elif update_index != -1:
            format_string = formats[8]
            add_update_prefix = True
        elif for_windows_earlier_than_index != -1:
            format_string = formats[6]
        elif all_supported_index != -1 :
            format_string = formats[7]
        elif earlier_than_build_index != -1:
            format_string = formats[5]
            # if text.find(self.product_list[0]) == -1:
                # text = self.product_list[0]+" "+text
        elif all_supported_sowftware_builds_before != -1:
            format_string = formats[4]
        elif all_supported_builds_before != -1:
            format_string = formats[3]
        elif earlier_than_index != -1:
            format_string = formats[2]
        elif earlier_index != -1:
            format_string = formats[1] 
        elif text.find("All versions of ") != -1:
            format_string = formats[0]
        
        # print("text: {}\n format:{}".format(text, format_string))
        dict_ = self.string_to_dict(text, format_string)
        if add_update_prefix:
            dict_["end_version"] = "Update "+dict_["end_version"]
            # print(dict_["end_version"])
        # print(dict_)
        return dict_
  
    
    def string_to_dict(self, string, pattern):
        regex = re.sub(r'{(.+?)}', r'(?P<_\1>.+)', pattern)
        search_terms = re.search(regex, string)
        if search_terms is not None:
            values = list(search_terms.groups())
            keys = re.findall(r'{(.+?)}', pattern)
            _dict = dict(zip(keys, values))
            return _dict


    def get_cpes(self, row, vendor, product):
        cpe23Uri_is_required = self.get_cve_id(row).startswith("CVE")
        pairs = self.get_product_version_pairs(row)
        products = self.get_product(row,vendor, product)
        versions = [""]
        if pairs is not None and len(pairs) > 0:
            products = pairs.keys()
            versions = pairs
        # print(products)
        return self.parse_cpes(versions, vendor, products
                                        , cpe23Uri_is_required)
    
    def build_product_list(self, link_parser):
         products = link_parser.get_tag_by_class("citrixproductslist").find("ul").find_all("li")
         product_names = list()
         for product in products:
             product_names.append(product.text)
         return product_names

    def build_meta_info(self, link_parser):
        meta = link_parser.get_tag_by_class("articale-meta-info")
        spans = meta.find_all("span")
        for span in spans:
            meta_value = span.get("data-swapid")
            # print(meta_value)
            if meta_value == "article_category":
                self.severity = span.text.strip().strip("|").strip()
            if meta_value == "article_create_date" :
                self.publishing_date_string = span.text.strip().strip("|").strip()
        


    def build_version_list(self, link_parser):
         desc = link_parser.get_tag_by_id("DescriptionofProblem")
         if desc is None:
             desc = link_parser.get_tag_by_class("parbase section text")
         if desc is not None:
            # print(desc)
            uls = desc.parent.find_all("ul")
            if len(uls) > 0 :
                for ul in uls:
                    # print(ul.prettify())
                    ul_heading = ul.previous_sibling.previous_sibling.text
                    # print(ul_heading)
                    if self.is_affected_version_list(ul_heading):
                        # print("in")
                        lis = ul.find_all("li")
                        if not lis:
                            lis = ul.find_all("p")
                        return lis
                    if self.is_resolved_version_list(ul_heading):
                        lis = ul.find_all("p")
                        return lis
            if len(uls) == 0:
                version_list = self.parse_versions_from_p_tag(link_parser)
                if len(version_list) > 0 :
                    return version_list

    def parse_versions_from_p_tag(self, link_parser):
        outer_div = link_parser.get_tag_by_class("parbase section text")
        # print(outer_div.prettify())
        versions_list = list()
        if outer_div is not None:
            all_p_tags = outer_div.find_all("p")
            if len(all_p_tags) > 1 :
                affected_version_p_tag = None
                for p_tag in all_p_tags:
                    if self.is_affected_version_list(p_tag.text):
                        # print(p_tag)
                        affected_version_p_tag = p_tag
                        continue
                    if affected_version_p_tag is not None:
                        # print(p_tag)
                        if self.is_version_p_tag_over(p_tag.text):
                            break
                        versions_list.append(p_tag)
            if len(all_p_tags) == 1:
                text = all_p_tags[0].text
                splits = safe_split(text, "This vulnerability affects the following product versions:")
                # if splits is None:
                #     splits = safe_split(text, "This vulnerability is present in the following versions")
                if splits is not None and len(splits) > 1:
                    versions_string = splits[1].strip()
                    # print(versions_string)
                    product = self.product_list[0]
                    versions_list = versions_string.split(product)
                    versions_list = versions_list[1:]
                    versions_list = list(map(lambda version: "{} {}".format(product, version), versions_list))

        return versions_list
        
    def is_version_p_tag_over(self, text):
        return find_any(text.lower(), [
            "the following platforms are not affected and do not require the firmware update:"
        ])
    def is_affected_version_list(self, text):
        return find_any(text.lower(), ["affected versions:", 
        "the vulnerability affects the following supported product versions", 
        "this vulnerability affects the following product versions",
        "this vulnerability affects the following citrix license server versions",
        "this vulnerability is present in the following versions",
        "this vulnerability affects the following products:",
        "following versions of citrix adc and netscaler gateway are impacted"
        ] )


    def is_resolved_version_list(self, text):
        return find_any(text.lower(), [
            "this issue has been resolved in the following"
        ] )


    def extract_version_from_description(self, row):
        all_p = self.current_row.find_all("p")
        for p in all_p:
            if p.text.find("Applicable Products") != -1 :
                spans = p.find_all("span")
                spans = spans[1:]
                products = self.get_product(row, None, None)
                version_string = ""
                version_dict = dict()
                for product in products:
                    for span in spans:
                        versions = span.text.split(product.text)
                        if len(versions) == 2:
                            version_string += versions[1].strip("_").replace("_",".")+","
                    version_string = version_string.strip(",")
                    version_dict[product] = version_string
                    version_string = ""
                return version_dict






