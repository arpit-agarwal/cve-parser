import json
common_names = [ 
    "Cross-Site Scripting",
    "Cross-Site-Scripting",
    "Cross-Site Request Forgery",
    "Code Injection",
    "Denial of service",
    "Directory Traversal",
    "Information Disclosure",
    "Privilege Escalation",
    "Missing Authorization",
    "Missing Authentication",
    "Missing XML Validation",
    "Remote Code Execution",
    "SQL Injection",
    ]
def get_common_name(desc):
    names = list()
    for name in common_names:
        if desc.lower().find(name.lower()) != -1 :
            if (name == "Cross-Site-Scripting") or (name == "Cross-Site Scripting"):
                name = "Cross-Site Scripting (XSS)"
            names.append(name)
    return names

def substring(string, prefix):
        start_index = string.find(prefix)
        version = string
        if start_index != -1:
            start_index = start_index+len(prefix)
            version = string[start_index:]
        return version

def dump_as_json(vendor, cves):
    securtiy_alerts =  {
            "type": "vendor",
            "source": vendor,
            "cves": cves
    } 
    return json.dumps(securtiy_alerts)

def split_on_any(string, delimiters):
        for delimiter in delimiters:
            if string.find(delimiter) != -1:
                versions = string.split(delimiter, 2)
                end = versions[1].strip()
                start = versions[0].strip()
                # if custom_handlers is not None:
                #     delimiter_handler = custom_handlers.get(delimiter)
                #     if delimiter_handler is not None:
                #         return delimiter_handler(start,end,delimiter)
                return (start, end, None)
        return None

def find_any(string, substrings):
    for substring in substrings:
        index = string.find(substring)
        if index != -1:
            return True

    return False

def deep_clean_string(text, substrings):
    for substring in substrings:
        text = text.replace(substring, "")
    return text

def split_pair(pair, and_patterns):
    singles = list()
    for and_pattern in and_patterns:
        and_index = pair.find(and_pattern)
        if and_index != -1 :
            singles += pair.split(and_pattern)

    return singles

def find_indices_for_sw_editions(version_string, editions):
    indices = list()
    subeditions = list()
    for edition in editions:
        INDEX = version_string.find(edition)
        if  INDEX != -1 :
            subeditions += split_pair(edition, [" & "," and "])
            if not edition in subeditions:
                indices.append(INDEX)
    return indices

def find_versions_for_sw_editions(sw_edition_indices, version_string):
    sw_edition_indices = sorted(sw_edition_indices)
    version_strings = list()
    for i in range(len(sw_edition_indices)-1):
        start = sw_edition_indices[i]
        end = sw_edition_indices[i+1]
        # print("{}:{}".format(start,end))
        version_string_per_edition = version_string[start: end].strip().strip(",")
        # print(version_string_per_edition)
        version_strings.append(version_string_per_edition)
    return version_strings

def find_sw_edition_in_version_string(version_string, editions):
    for edition in editions:
        index = version_string.find(edition)
        if index != -1:
            return (index, edition)

def build_sw_edition_version_pair(version_string, editions):
    edition_version_pair = find_sw_edition_in_version_string(version_string, editions)
    if edition_version_pair is not None:
        (index, edition)  = edition_version_pair
        return (edition, version_string[index+len(edition):])

def safe_split(string, substring):
    index = string.find(substring)
    if index != -1:
        return string.split(substring)
    return None