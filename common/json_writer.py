
from datetime import datetime
import json
from common.utils import get_publish_date, format_date
from mongodb.utils import parse_version, \
    TableColumnIndex, \
    PUBLISHING__DATE_INPUT_FORMAT

TIMESTAMP_FORMAT = '%Y-%m-%dT%H:%MZ'


class JSONWriter:

    def __init__(self, header, alerts):
        self.alerts = alerts
        self.header = header

    def get_security_alerts_json(self, type_, vendor, url, product, webpage_name):
        securtiy_alerts = {
            "type": type_,
            "source": vendor,
            "cves": self.parse_alerts(vendor, url,product, webpage_name)
        }
        return json.dumps(securtiy_alerts)

    def parse_alerts(self, vendor, url,product, webpage_name):
        collection = list()
        alerts_list = self.alerts

        for alert in alerts_list:
            collection.append(self.parse_alert(
                alert, vendor, url,product, webpage_name))
        return collection

    def parse_alert(self, alert, vendor, url,product, webpage_name):
        row = alert.find_all("p")
        published_date = get_publish_date(
            row[TableColumnIndex.PUBLISHINGDATE].text,
            PUBLISHING__DATE_INPUT_FORMAT)
        json_row = {
            "timestamp": format_date(datetime.utcnow(), TIMESTAMP_FORMAT),
            "published_date": format_date(published_date, TIMESTAMP_FORMAT),
            "id": row[TableColumnIndex.CVE].text,
            "url": url,
            "name": webpage_name,
            "description": row[TableColumnIndex.DESCRIPTION].text,
            "cpes":  self.parse_cpes(row[TableColumnIndex.VERSION].text,
                                     vendor,
                                     product)
        }
        return json_row

    def parse_cpes(self, cpes, vendor, product):
        categaory = "a"
        cpes_list = cpes.split(",")
        cpes_collection = list()
        for cpe in cpes_list:
            json_cpe = {
                "vendor": vendor,
                "category": categaory,
                "product": product,
            }
            if cpe.find("(") != -1:
                cpe = cpe.split("(")[0]
            versions = parse_version(cpe)
            if versions == "Invalid":
                continue
            if versions is None:
                json_cpe["version"] = cpe.strip()
            else:
                (start, end, sw_edition) = versions
                json_cpe["versionEndIncluding"] = end
                if start is not None:
                     json_cpe["versionStartIncluding"] = start 
                if sw_edition is not None:
                    json_cpe["sw_edition"] = sw_edition

            cpes_collection.append(json_cpe)
        return {"operator": "OR", "cpe_list": cpes_collection}
