from datetime import datetime

class BaseRowParser:

    def __init__(self):
        self.timestamp_format = '%Y-%m-%dT%H:%MZ'
        self.publishing__date_input_format = "%B %d, %Y"
        self.publishing_date = 0
        self.product = 1
        self.description = 2
        self.version = 3
        self.cve = 5
        self.severity = None

    def parse(self, row, vendor, url,product, webpage_name):
            cells = self.get_cells(row)
            if cells is not None:
                published_date = self.get_publish_date(cells)
                cpes = self.get_cpes(cells, vendor, product)
                cvssv2 = self.get_cvssv2(cells)
                cvssv3 = self.get_cvssv3(cells)
                threat_info = self.get_threat_info(cells)
                json_row = self.get_json_row(cells, published_date, url, webpage_name, cpes, cvssv2, cvssv3, threat_info)
                return json_row
            return None

    def get_cells(self,row):
        return row.find_all("td")

    def trim_version_string(self, version_string):
        if version_string.find("(") != -1:
            version_string = version_string.split("(")[0]
        return version_string
    
    def parse_version(self,version_string):
        return self.split_on_any(version_string, ["-", "to", "and"])

    def split_on_any(self, string, delimiters):
        for delimiter in delimiters:
            if string.find(delimiter) != -1:
                versions = string.split(delimiter, 2)
                end = versions[1].strip()
                start = versions[0].strip()
                if delimiter == "and":
                    return self.do_and_dilimiter_handling(start, end)

                return (start, end, None)
        return None


    def do_and_dilimiter_handling(self, start, end):
        if start.strip() == "":
            return "Invalid"
        if end == "earlier":
            end = start
            start = None
        return (start, end, None)

    def get_publish_date(self,cells):
        return datetime.strptime(
                cells[self.publishing_date].text,
                self.publishing__date_input_format)

    def format_date(self, date, date_format):
        return date.strftime(date_format)

    def get_cpes(self, cells, vendor, product):

        return self.parse_cpes(self.get_version_string(cells),
                                    vendor,
                                    self.get_product(cells, vendor, product))

    def get_product(self, cells, vendor, product):
        return product

    def get_version_string(self, cells):
        return cells[self.version].text

    def get_cpe_list(self, vendor, product, category, cpes):
         cpes_list = cpes.split(",")
         return [(vendor, product, category, cpes_list)]

    def build_product_cpes_json(self, cpes_list, vendor, product, category, cpe23Uri_is_required):
        cpes_collection = list()
        for cpe in cpes_list:
            json_cpe = {
                "vendor": vendor,
                "category": category,
                "product": product,
            }

            cpe = self.trim_version_string(cpe)
            versions = self.parse_version(cpe)
            if versions == "Invalid":
                continue
            if versions is None:
                json_cpe["version"] = cpe.strip()
            elif len(versions) == 1:
                json_cpe["version"] = versions[0]
            else:
                # print(versions)
                (start, end, sw_edition) = versions
                if start == end :
                    json_cpe["version"] = start
                else  :
                    if start is not None:
                            json_cpe["versionStartIncluding"] = start 
                    json_cpe["versionEndIncluding"] = end
                if sw_edition is not None:
                    json_cpe["sw_edition"] = sw_edition
            
            if cpe23Uri_is_required :
                cpe_version = '*'
                if "version" in json_cpe: 
                    cpe_version = json_cpe.get("version")
                json_cpe["cpe23Uri"] = self.build_cpe23_uri(category,vendor, product, cpe_version)
            cpes_collection.append(json_cpe)
        return cpes_collection

    def parse_cpes(self, cpes, vendor, product, cpe23Uri_is_required = True):
        cpes_list_tuple = self.get_cpe_list(vendor, product, "a",cpes)
        cpes_collection = list()
        for (vendor, product, category, cpes_list) in cpes_list_tuple :
            cpes_collection += self.build_product_cpes_json(cpes_list, vendor, product, category, cpe23Uri_is_required)
        return {"operator": "OR", "cpe_list": cpes_collection}

    def get_cvssv2(self, cells):
        return None

    def get_cvssv3(self, cells):
        return None

    def get_threat_info(self, cells):
        return None

    def build_cpe23_uri(self,category,vendor, product, version):
        return str.format("cpe:2.3:{}:{}:{}:{}:*:*:*:*:*:*:*",category,vendor, product, version)

    def get_cve_id(self, cells): 
        cve = cells[self.cve]
        if cve is not None:
            cve = cve.text.strip()
        else :
            cve = "UNKNOWN"
        return cve

    def get_description(self, cells): 
        desc = cells[self.description].text.strip()
        desc = desc.replace("\u00a0","").replace("\u00c2","")
        return desc

    def get_json_row(self,cells, published_date, url, webpage_name, cpes, cvssv2 = None, cvssv3 = None, threat_info = None):
        json_row = {
            "timestamp": self.format_date(datetime.utcnow(), self.timestamp_format),
            "published_date": self.format_date(published_date, self.timestamp_format),
             "id": self.get_cve_id(cells),
             "url": url,
             "name": webpage_name,
             "description": self.get_description(cells),
             "cpes":  cpes
        }
        if cvssv2 is not None:
            json_row["cvssv2"] = cvssv2
        if cvssv3 is not None:
            json_row["cvssv3"] = cvssv3
        if threat_info is not None:
            json_row["threat_info"] = threat_info

        return json_row


