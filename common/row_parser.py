from datetime import datetime
from common.utils import get_common_name, split_on_any, safe_split
from bs4 import NavigableString

class BaseRowParser:

    def __init__(self):
        self.timestamp_format = '%Y-%m-%dT%H:%MZ'
        self.publishing__date_input_format = "%B %d, %Y"
        self.publishing_date = None
        self.publishing_date_index = 0
        self.product = 1
        self.description = 2
        self.version = 3
        self.cve = 5
        self.cvss2_severity_index = None
        self.cvss2_score_index = None
        self.cvss2_vector_index = None
        self.cvss3_severity_index = None
        self.cvss3_score_index = None
        self.cvss3_vector_index = None

    def parse(self, row, vendor, url,product, webpage_name):
            cells = self.get_cells(row)
            if cells is not None:
                id_ = self.get_cve_id(cells)
                if id_ is not None  :
                    published_date = self.get_publish_date(cells, self.publishing_date)
                    cpes = self.get_cpes(cells, vendor, product)
                    cvssv2 = self.get_cvssv2(cells)
                    cvssv3 = self.get_cvssv3(cells)
                    threat_info = self.get_threat_info(cells)
                    json_row = self.get_json_row(cells,id_, published_date, url, webpage_name, cpes, cvssv2, cvssv3, threat_info)
                    return json_row 
            return None

    def get_cells(self,row):
        return row.find_all("td")
    
    def get_cve_id(self, cells): 
        return self.parse_node(cells, self.cve)
    
    def get_description(self, cells): 
        desc =  self.parse_node(cells, self.description)
        desc = desc.replace("\u00a0","").replace("\u00c2","")
        return desc

    def get_product(self, cells, vendor, product):
        if product is not None:
            return product
        return self.parse_node(cells, self.product)

    def get_version_string(self, cells):
        return self.parse_node(cells, self.version)

    def get_publish_date(self,cells, date=None):
        if date is None:
            date = cells[self.publishing_date_index].text
        return datetime.strptime( date,
                self.publishing__date_input_format)

    def get_cpes(self, cells, vendor, product):
        return self.parse_cpes(self.get_version_string(cells),
                                    vendor,
                                    self.get_product(cells, vendor, product))

    def get_cvssv2(self, cells):
        base_score = self.get_cvsv2_score(cells)
        vector = self.get_cvsv2_vector(cells)
        severity = self.get_cvsv2_severity(cells)
        cvssv2 = {}
        self.add_to_dict(cvssv2, "severity", severity)
        self.add_to_dict(cvssv2, "base_score", base_score)
        self.add_to_dict(cvssv2, "vector_string", vector)
        if not cvssv2:
            return None
        return cvssv2

    def get_cvssv3(self, cells):
        base_score = self.get_cvsv3_score(cells)
        vector = self.get_cvsv3_vector(cells)
        severity = self.get_cvsv3_severity(cells)
        cvssv3 = {}
        self.add_to_dict(cvssv3, "severity", severity)
        self.add_to_dict(cvssv3, "base_score", base_score)
        self.add_to_dict(cvssv3, "vector_string", vector)
        if not cvssv3:
            return None
        return cvssv3

    def get_threat_info(self, cells):
        desc  = self.get_description(cells)
        common_names = get_common_name(desc)
        if len(common_names) > 0 :
            return {
                "common_names": common_names,
            }
        return None

    def get_json_row(self,cells,id_, published_date, url, webpage_name, cpes, cvssv2 = None, cvssv3 = None, threat_info = None):
        json_row = {
            "timestamp": self.format_date(datetime.utcnow(), self.timestamp_format),
            "published_date": self.format_date(published_date, self.timestamp_format),
             "id": id_,
             "url": url,
             "name": webpage_name,
             "description": self.get_description(cells),
             "cpes":  cpes
        }
        self.add_to_dict(json_row, "cvssv2", cvssv2)
        self.add_to_dict(json_row, "cvssv3", cvssv3)
        self.add_to_dict(json_row, "threat_info", threat_info)
        return json_row

    def get_cvsv3_score(self,cells):
        return self.parse_node(cells, self.cvss3_score_index)
    
    def get_cvsv3_vector(self,cells):
        return self.parse_node(cells, self.cvss3_vector_index)

    def get_cvsv3_severity(self,cells):
        severity = self.parse_node(cells, self.cvss3_severity_index)
        return self.normalize_severity(severity)

    def get_cvsv2_score(self,cells):
        return self.parse_node(cells, self.cvss2_score_index)
    
    def get_cvsv2_vector(self,cells):
        return self.parse_node(cells, self.cvss2_vector_index)

    def get_cvsv2_severity(self,cells):
        severity = self.parse_node(cells, self.cvss2_severity_index)
        return self.normalize_severity(severity)

    def parse_node(self,cells, index):
        if index is not None and cells is not None:
            node = cells[index]
            # print("type: {}, value: {}".format(type(node), node))
            if node is not None:
                if(isinstance(node, (NavigableString, list, str))):
                    return node
                
                text = node.text
                if text is not None:
                    return text.strip()
        return None

    def add_to_dict(self, dict_ref, key, value):
        if value is not None:
            dict_ref[key] = value

    def format_date(self, date, date_format):
        return date.strftime(date_format)

    def build_cpe23_uri(self,category,vendor, product, version):
        return str.format("cpe:2.3:{}:{}:{}:{}:*:*:*:*:*:*:*",category,vendor, product, version)

    def parse_cpes(self, cpes, vendor, product, cpe23Uri_is_required = True):
        cpes_list_tuple = self.get_cpe_list(vendor, product, "a",cpes)
        cpes_collection = list()
        for (vendor, product, category, cpes_list) in cpes_list_tuple :
            # print(vendor, product, category, cpes_list)
            cpes_collection += self.build_product_cpes_json(cpes_list, vendor, product, category, cpe23Uri_is_required)
        return {"operator": "OR", "cpe_list": cpes_collection}
    
    def get_cpe_list(self, vendor, product, category, cpes):
        if not isinstance(product,list):
            product = [product]
            cpes = [cpes]

        tuples = list()
        i=0
        for current_product in product:
            current_product_tuple = self.get_cpe_list_per_product(vendor, current_product ,category, cpes[i])
            # print(current_product_tuple)
            tuples += current_product_tuple
            i = i+1

        return tuples

    def get_cpe_list_per_product(self, vendor, product, category, cpes):
         cpes_list = cpes.split(",")
         return [(vendor, product, category, cpes_list)]

    def build_product_cpes_json(self, cpes_list, vendor, product, category, cpe23Uri_is_required):
        cpes_collection = list()
        for cpe in cpes_list:
            json_cpe = {
                "vendor": vendor,
                "category": category,
            }
            pair = safe_split(product, "::")
            if pair is not None:
                (product,sw_edition) = pair
                self.add_to_dict(json_cpe, "product", product)
                self.add_to_dict(json_cpe, "sw_edition",sw_edition)
            else:
                self.add_to_dict(json_cpe, "product", product)

            if cpe is not None and cpe != "":
                cpe = self.trim_version_string(cpe)
                versions = self.parse_version(cpe)
                if versions == "Invalid":
                    continue
                if versions is None:
                    json_cpe["version"] = cpe.strip()
                elif len(versions) == 1:
                    json_cpe["version"] = versions[0]
                else:
                    # print(versions)
                    (start, end) = versions
                    if start == end :
                        json_cpe["version"] = start
                    else:
                        self.add_to_dict(json_cpe, "versionStartIncluding", start)
                        versions = safe_split(end,"Exclude:")
                        if versions is not None:
                            self.add_to_dict(json_cpe,"versionEndExcluding", versions[1].strip())
                        else:
                            self.add_to_dict(json_cpe, "versionEndIncluding", end)


            if cpe23Uri_is_required :
                cpe_version = '*'
                if "version" in json_cpe: 
                    cpe_version = json_cpe.get("version")
                json_cpe["cpe23Uri"] = self.build_cpe23_uri(category,vendor, product, cpe_version)
            cpes_collection.append(json_cpe)
        return cpes_collection

    def trim_version_string(self, version_string):
        if version_string.find("(") != -1:
            version_string = version_string.split("(")[0]
        return version_string
    
    def parse_version(self,version_string):
        versions = safe_split(version_string, "prior to")
        if versions is not None:
            end = "Exclude: {0}".format(versions[1].strip())
            return (None,end)
        versions = safe_split(version_string, "from")
        if versions is not None :
            rest = versions[1].strip()
            versions = safe_split(rest, "to")
            if versions is None:
                return (rest, None)
            return (versions[0].strip(), versions[1].strip())
        
        versions = safe_split(version_string, "<=")
        if versions is not None:
            end = versions[1].strip()
            return (None, end)
   
        index_of_before = version_string.find("before")
        if  index_of_before != -1 :
            versions = version_string.split()
            len_version = len(versions)

            if len_version == 1:
                end = version_string[index_of_before+5:]
            elif len_version == 3:
                end = versions[2]
            else: 
                end = versions[1]
            return (None, end)
        
        return split_on_any(version_string, ["-", "to", "and"])

    def normalize_severity(self, severity):
        if severity is not None:
            if severity == "Hot News":
                return "CRITICAL"
            if severity == "Important":
                return "HIGH"
            elif severity ==  "Moderate":
                return "MEDIUM"
            return severity.upper()
        return None



