from common.row_parser import BaseRowParser
from common.html_parser import HTMLParser
from datetime import datetime
from bs4 import NavigableString
from common.utils import get_publish_date, should_parse_bulletin


class RSSBaseRowParser(BaseRowParser):

    def __init__(self, from_date_string, to_date_string):
        super().__init__()
        self.cve_tag = "cve"
        self.from_date = get_publish_date(from_date_string)
        self.to_date = get_publish_date(to_date_string)
        self.publishing_date_tag = "pubDate"
        self.last_modified_date_tag = None
        self.description_tag = "title"
        self.publishing_date = None
        self.timestamp_format = '%Y-%m-%dT%H:%MZ'
        self.last_modified_date_input_format = "%a, %d %b %Y %H:%M:%S %Z"
    
    def shouldPraseRow(self, row):
        date_string = row.find("dc:date").text.split('T')[0]
        # print(date_string)
        date = datetime.fromisoformat(date_string)
        # print(date)
        return should_parse_bulletin(date, self.from_date, self.to_date)

    def parse(self, row, vendor, url,product, webpage_name):
        if self.shouldPraseRow(row) is True:
            return super().parse(row,vendor, url,product, webpage_name )
        return "Skipped"
    
    def get_cells(self,row):
        return row
    
    def get_cve_id(self, row):
        heading = self.parse_node(row, self.cve_tag)
        return heading 

    def get_description(self, row):
        return self.parse_node(row, self.description_tag)
    
    def get_publish_date(self, row, date=None):
        if date is None:
            date = self.parse_node(row, self.publishing_date_tag)
        if date is not None:
            return datetime.strptime(date,
                self.publishing__date_input_format)

    def get_last_modified_date(self, row):
        date = self.parse_node(row, self.last_modified_date_tag)
        if date is not None:
            return datetime.strptime(date,
                    self.last_modified_date_input_format)
    
    def parse_node(self,row, tag):
        if tag is not None and row is not None:
            node = row.find(tag)
            # print("row: {}, tag: {}, node: {}".format(row, tag, node))
            if node is not None:
                if(isinstance(node, (NavigableString, list, str))):
                    return node
                
                text = node.text
                if text is not None:
                    return text.strip()
        return None

    def get_cpe_list(self, vendor, product, category, cpes):
        tuples = list()
        for current_product in product:
            # current_product_versions = cpes
            # print(current_product)
            if type(cpes) is dict:
                current_product_versions = cpes.get(current_product)
                if current_product_versions is not None:
                    current_product_tuple = self.get_cpe_list_per_product(vendor, current_product, category, current_product_versions)
                    tuples += current_product_tuple
            else:
                current_product_tuple = self.get_cpe_list_per_product(vendor, current_product, category, cpes)
                tuples += current_product_tuple

        return tuples
    
    def get_cpe_list_per_product(self, vendor, product, category, cpes):
        # if cpes is None:
        #     cpes_list = [cpes]
        # else:
        #     cpes_list = cpes.split(",")
        return [(vendor, product, category, cpes)]