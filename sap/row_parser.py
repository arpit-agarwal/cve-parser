from datetime import datetime
from common.row_parser import BaseRowParser
from common.utils import get_common_name
from bs4 import BeautifulSoup, NavigableString

class RowParser(BaseRowParser):

    def __init__(self, publishing_date):
        super().__init__()
        self.publishing_date = publishing_date
        self.publishing__date_input_format = "On %dth of %B %Y"
        self.cve = 0
        self.description = 1
        self.product = 2
        self.version = 3
        self.severity = 4
        self.cvss3_index = 5

    def get_publish_date(self,cells):
        return datetime.strptime(
            self.publishing_date,
            self.publishing__date_input_format)

    def add_product_info(self,info, plist):
        # print(info)
        info = self.cleanup_product_info(info)
        # print(info)
        plist.append(info)

    def add_version_info(self,info, vlist):
        info = self.cleanup_version_info(info)
        # print(info)
        vlist.append(info)

    def make_product_or_version_info(self, text, current_info, product_list, version_list):
        # print("rw text: {}, current info: {}".format(text, current_info))
        if text.find("Version") != -1 :
            versions = text.split("Version")
            product = versions[0].strip()
            # print(product)
            if len(product) > 0 :
                 current_info += product
            self.add_product_info(current_info, product_list)
            if len(versions) > 1 :
                version = versions[1].strip().strip("-").strip("s")
                return version
            return ""
        elif text == "Product" :
            if current_info != "":
                self.add_version_info(current_info, version_list)
                return ""
            return current_info
        elif text == "Component" :
            if len(product_list) > len(version_list):
                self.add_version_info(current_info, version_list)
                return ""
            return current_info
        elif text == "Software Component" :
            if len(product_list) > len(version_list):
                self.add_version_info(current_info, version_list)
                return ""
            return current_info
        else :
            return current_info+text

# CVE-2018-1270, CVE-2018-1275 => Nov 2018 => 18
# CVE-2015-5237, CVE-2018-2441 => Aug 2018 => 21
# CVE-2018-2433, CVE-2018-2440 => JUk 2018 => 22
            # "id": "CVE-2019-0308", June 2019
            # "url": "https://wiki.scn.sap.com/wiki/x/MgQbHw",
#             "id": "CVE-2019-0271", Mar 2019             "url": "https://wiki.scn.sap.com/wiki/x/0IC4Hg",
#             "id": "CVE-2018-7559", 0276 Mar 2019             "url": "https://wiki.scn.sap.com/wiki/x/0IC4Hg"



    def build_product_info(self, title_cell):
        # print(title_cell)
        product_list = list()
        version_list = list()
        original_title_Cell = title_cell
        if title_cell.u is None:
            title_cell = title_cell.parent
        if title_cell.u is None:
            product_node = original_title_Cell.span
        elif title_cell.u.text.strip() == "" :
            u_tags= title_cell.find_all("u")
            u_tag  = u_tags[0]
            i = 1
            while u_tag.text.strip() == "":
                u_tag = u_tags[i]
                i += 1

            product_node = u_tag.next_sibling
        else:
            product_node = title_cell.u.next_sibling

        # print(product_node)
        if isinstance(product_node, NavigableString):
            text = product_node.strip()
        elif product_node is None :
            text = ""
        else: 
            text = product_node.text
        # print(text)
        if product_node is None:
            spans = None
        else: 
            spans = product_node.next_sibling

        i = 0
        current_info = self.make_product_or_version_info(text,"", product_list, version_list)
        while spans is not None :
            if spans.string is None:
                j = 0
                for string in spans.stripped_strings:
                    text = string.strip()
                    # print("{}.{}: {}".format(i, j,string.strip()))
                    j += 1
                    current_info = self.make_product_or_version_info(text,current_info, product_list, version_list)
            else : 
                text = spans.string.strip()
                current_info = self.make_product_or_version_info(text,current_info, product_list, version_list)
                # print("raw text: {}".format(text))
 
            
            # print("{}: {}".format(i, current_info))
            spans = spans.next_sibling
            i += 1
        self.add_version_info(current_info, version_list)
        # print(product_list)
        # print(version_list)
        return (product_list, version_list)

    def cleanup_product_info(self,info):
        info = info.replace("Â", "").replace("â","").replace("\u00a0", "")
        info = info.replace("\u0080\u0093", "").replace("\u00c2","")
        info = info.strip("-").strip(",")
        start_index = info.find("S")
        if start_index != -1 :
            return info[start_index:]
        return info.strip()

    def cleanup_version_info(self,info):
        info = info.replace("Â", "").replace("â","").replace("\u00a0", "")
        info = info.replace("\u0080\u0093", "").replace("\u00c2","")
        return info.strip(",").strip()

    def create_cells_for_update(self, title_cell):
        return None

    def get_cells(self,row):
        # print(row.prettify())
        tds = row.find_all("td")
        cells = list()
        title_cell = tds[1].find("p")

        if title_cell is None: 
            title_cell = tds[1]

        # print(title_cell.prettify())
        strong_tag = title_cell.strong

        if strong_tag is None:
            strong_tag = title_cell.em

        title = strong_tag.text.strip()
        if title == "":
            all_strong = title_cell.find_all("strong")[1:]
            # print(all_strong)
            for strong_tag in all_strong:
                # print(strong_tag.prettify())
                title = strong_tag.text
                if title != "": break

        # print(title)
        firstword = title.split()[0]
        if  firstword != "Update" and firstword != "Multiple" :
            cells.append(title_cell.a)
            cells.append(title_cell.strong)
            
            info = self.build_product_info(title_cell)
            cells += info
            cells.append(tds[2])
            cells.append(tds[3].a)
        else :
            cells = self.create_cells_for_update(title_cell)

        return cells


    def get_version_string(self, cells):
        return cells[self.version]
    
    def get_product(self, cells, vendor, product):
        return cells[self.product]

    def remove_vendor_name(self, product):
        index = product.find("SAP")
        if index != -1 :
            return product[3:].strip()
        return product

    def parse_version(self, version_string):
        # print(version_string)
        if version_string.find("<=") != -1 :
            versions = version_string.split("<=")
            end = versions[1].strip()
            return (None, end, None)
        if version_string.find("before") != -1 :
            versions = version_string.split()
            end = versions[1]
            if len(versions) == 3:
                end = versions[2]
            return (None, end, None)
        if version_string.find("to") != -1 :
            versions = version_string.split("to")
            return (versions[0].strip(), versions[1].strip(), None)
        if version_string.find("and") != -1 :
            versions = version_string.split("and")
            return (versions[0].strip(), versions[1].strip(), None)
        else :
            versions = list()
            version = version_string.strip().strip("-")
            versions.append(version)
            return versions
        
    def cleanup_string(self, string, prefix):
            start_index = string.find(prefix)
            version = string
            if start_index != -1:
                start_index = start_index+len(prefix)
                version = string[start_index:]
            return version

    def normalize_severity(self, severity): 
        if severity == "Hot News":
            return "CRITICAL"
        return severity.upper()

    def get_cvssv3(self, cells):
        a_node  = cells[self.cvss3_index]
        base_score = a_node.text
        vector = a_node.get('href').split('#')[1]
        return {
            "severity": self.normalize_severity(cells[self.severity].text.strip()),
            "base_score": base_score,
            "vector_string": vector
        }

    def get_threat_info(self, cells):
        desc  = self.get_description(cells)
        common_names = get_common_name(desc)
        if len(common_names) > 0 :
            return {
                "common_names": common_names,
            }
        return None

    def get_cpe_list(self, vendor, product, category, cpes):
        tuples = list()
        i=0
        for current_product in product:
            current_product_tuple = self.get_cpe_list_per_product(vendor, self.remove_vendor_name(current_product),category, cpes[i])
            # print(current_product_tuple)
            tuples += current_product_tuple
            i =+ 1
        return tuples

    def get_cpe_list_per_product(self, vendor, product, category, cpes):
        tuples = list()
        cpes_list = self.split_cpes(cpes)
        # print("{}: {}".format(product, cpes_list))
        for version_string in cpes_list:
            current_product = product
            if version_string is None or version_string is "":
                continue
            # print(version_string)
            colon_index = version_string.find(":")
            if colon_index != -1 :
                (product_suffix, version_string) = version_string.split(":")
                current_product +=  product_suffix

            version_string = version_string.strip(")")
            version_string = version_string.replace("(", "")
            version_string = version_string.replace("and", ","  )
            # print(version_string)
            versions = version_string.split(",")
            firstVersion = versions[0].strip("-").strip()
            # print(firstVersion)
            # print("{0}: {1}".format(current_product,version_string))
            if firstVersion.find("before") != -1 :
                version_string = firstVersion
            elif firstVersion.find(" to ") != -1 :
                version_string = firstVersion
            elif firstVersion.find("<=") != -1 :
                version_string = firstVersion
            elif not firstVersion[0].isdigit():
                (product_suffix, firstVersion) = self.extract_product_suffix(firstVersion)
                current_product +=  product_suffix

            versions[0] = firstVersion

            current_product = current_product.strip()
            tuples.append((vendor, current_product, category, versions))

        return tuples

    def extract_product_suffix(self, version):
        for edition in self.editions:
            index = version.find(edition)
            if index != -1:
                return [edition, version[index+len(edition):]]
        if version.find(" ") != -1:
            return version.rsplit(" ", 1)
        else:
            return [version[0:-3], version[-3:]]

    editions = ["S4CORE", "SAP_FIN", "SAP_APPL", "(SAP_Appl)", "(EA_Appl)", "EPPM", "CPRXRPM", "EA-FINSERV", "KRNL32NUC & KRNL32UC", "KRNL64NUC & KRNL64UC", "KERNEL", "UICUAN", "SAPSCORE", "engineapi", "servercode" , "KRNL32NUC", "KRNL32UC", "KRNL64NUC", "KRNL64UC", "SAP_XIESR and SAP_XITOOL", "SAP_XIESR", "SAP_XITOOL", "SAP_XIPCK", "Bank/CFM" , "SAPSCORE"]

    def split_cpes(self, cpes):
        splited_cpes = cpes.split(";")
        if len(splited_cpes) == 1:
            indices = list()
            subeditions = list()
            for edition in self.editions:
                INDEX = cpes.find(edition)
                if  INDEX != -1 :
                    and_index = edition.find(" & ")
                    if and_index != -1 :
                        subeditions += edition.split(" & ")

                    and_index = edition.find(" and ")
                    if and_index != -1 :
                        subeditions += edition.split(" and ")

                    if not edition in subeditions:
                        indices.append(INDEX)
            indices = sorted(indices)
            indices.append(len(cpes))
            # print(indices)
            cpes_list = list()
            for i in range(len(indices)-1):
                start = indices[i]
                end = indices[i+1]
                # print("{}:{}".format(start,end))
                cpe = cpes[start: end].strip().strip(",")
                # print(cpe)
                cpes_list.append(cpe)
            if len(cpes_list) > 0:
                return cpes_list
        return splited_cpes

    def index_parser(self, substring, cpes):
        INDEX = cpes.find(substring)
        if  INDEX != -1 :
            cpes_list = [ cpes[0:INDEX].strip(","), cpes[INDEX:].strip(",")]
            return cpes_list


        



