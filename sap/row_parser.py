from datetime import datetime
from common.row_parser import BaseRowParser
from common.utils import deep_clean_string, find_any, split_pair, find_indices_for_sw_editions, safe_split, find_versions_for_sw_editions, build_sw_edition_version_pair
import sap.parser_utils as ParserUtil
from bs4 import BeautifulSoup, NavigableString

class RowParser(BaseRowParser):
    editions = ["S4CORE", "SAP_FIN", "SAP_APPL", "(SAP_Appl)", "(EA_Appl)", "EPPM", "CPRXRPM", "EA-FINSERV", "KRNL32NUC & KRNL32UC", "KRNL64NUC & KRNL64UC", "KERNEL", "UICUAN", "SAPSCORE", "engineapi", "servercode" , "KRNL32NUC", "KRNL32UC", "KRNL64NUC", "KRNL64UC", "SAP_XIESR and SAP_XITOOL", "SAP_XIESR", "SAP_XITOOL", "SAP_XIPCK", "Bank/CFM" , "SAPSCORE"]

    def __init__(self, publishing_date):
        super().__init__()
        self.publishing_date = publishing_date
        self.publishing__date_input_format = "On %dth of %B %Y"
        self.cve = 0
        self.description = 1
        self.product = 2
        self.version = 3
        self.cvss3_score_index = 5
        self.cvss3_vector_index = 5
        self.cvss3_severity_index = 4

    def get_cells(self,row):
        # print(row.prettify())
        tds = super().get_cells(row)
        cells = list()

        title_cell, title = ParserUtil.parse_description_and_node(tds[1])

        # print(title)
        firstword = title.split()[0]
        cells.append(title_cell.a)

        if  firstword == "Update":
            titles = title_cell.text.split(":")
            # print(titles)
            if len(titles) == 2:
                title = titles[1]

        cells.append(title)
        info = self.build_product_info(title_cell)
        cells += info
        cells.append(tds[2])
        cells.append(tds[3].a)

        return cells
        
    def get_description(self,cells):
        description = super().get_description(cells)
        description = description.replace("Additional CVEs", "")
        return description

    def get_cvsv3_vector(self,cells):
        a_node  = cells[self.cvss3_vector_index]
        vector = a_node.get('href').split('#')[1]
        return vector

    def build_product_info(self, title_cell):
        # print(title_cell)
        product_list = list()
        version_list = list()
        text, spans = ParserUtil.parse_u_for_product(title_cell, "Related CVE")
        # print(spans)
        ParserUtil.build_product_info_from_spans(text,spans,product_list, version_list, self.make_product_or_version_info)
        # print(product_list)
        # print(version_list)
        return (product_list, version_list)

    def make_product_or_version_info(self, text, current_info, product_list, version_list):
        # print("rw text: {}, current info: {}".format(text, current_info))
        if text.find("Version") != -1 :
            versions = text.split("Version")
            product = versions[0].strip()
            # print(product)
            if len(product) > 0 :
                 current_info += product
            ParserUtil.add_product_info(current_info, product_list)
            if len(versions) > 1 :
                version = versions[1].strip().strip("-").strip("s")
                # print(version)
                if version.find("Product") != -1 :
                    versions = version.split("Product")
                    ParserUtil.add_version_info(versions[0], version_list)
                    # print(versions[1])
                    return self.make_product_or_version_info(versions[1], "", product_list, version_list) 
                return version
            return ""
        elif text == "Product" :
            if current_info != "":
                ParserUtil.add_version_info(current_info, version_list)
                return ""
            return current_info
        elif text == "Component" :
            if len(product_list) > len(version_list):
                ParserUtil.add_version_info(current_info, version_list)
                return ""
            return current_info
        elif text == "Software Component"  or text == "Software Components" :
            if len(product_list) > len(version_list):
                ParserUtil.add_version_info(current_info, version_list)
                return ""
            return current_info
        else :
            return current_info+text

    def get_cpe_list_per_product(self, vendor, product, category, cpes):
        tuples = list()
        cpes_list = self.split_cpes(cpes)
        # print("{}: {}".format(product, cpes_list))
        for version_string in cpes_list:
            current_product = product
            if version_string is None or version_string is "":
                continue
            # print(version_string)
            colon_index = version_string.find(":")
            if colon_index != -1 :
                (product_suffix, version_string) = version_string.split(":")
                current_product +=  product_suffix

            version_string = deep_clean_string(version_string, [")", "(", "-"])
            version_string = version_string.replace("and", ","  )
            # print(version_string)
            versions = version_string.split(",")
            firstVersion = versions[0].strip()
            # print("{0}: {1}".format(current_product,version_string))
            if not (find_any(firstVersion, ["before"," to ", "<="]) or firstVersion[0].isdigit()):
                (product_suffix, firstVersion) = self.extract_product_suffix(firstVersion)
                current_product +=  product_suffix

            versions[0] = firstVersion

            current_product = current_product.strip()
            tuples.append((vendor, current_product, category, versions))

        return tuples

    def split_cpes(self, cpes):
        splited_cpes = cpes.split(";")
        if len(splited_cpes) == 1:
            indices = find_indices_for_sw_editions(cpes, self.editions)
            indices.append(len(cpes))
            # print(indices)
            cpes_list = find_versions_for_sw_editions(indices, cpes)
            if len(cpes_list) > 0:
                return cpes_list
        return splited_cpes

    def extract_product_suffix(self, version):
        pair = build_sw_edition_version_pair(version, self.editions)
        if pair is not None:
            return pair 
        if version.find(" ") != -1:
            return version.rsplit(" ", 1)
        else:
            return [version[0:-3], version[-3:]]

    def parse_version(self, version_string):
        # print(version_string)
        versions = super().parse_version(version_string)
        if versions is None:
            version = version_string.strip().strip("-")
            versions = [version]
        return versions
 
# SAP KERNAL UNC and similar pattern
# Aug 2018: CVE-2018-2441; July 2018: CVE-2018-2433
# June 2019: CVE-2019-0308

# multi product parsing
# Aug 2018: Fixing Logjam and Alternative chains 
# Aug 2019: 0381
# EP 2019: 0330
# May 2019: KEr
# APr 2019 0265
# Mar 2019: 270 0276
# Feb 2019 0257
#feb 2018 2367 , 2395, 2374

# version parsing
# Feb 2020 0271

# SAP Internet Graphics ServerRelated 



